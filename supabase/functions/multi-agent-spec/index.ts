import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import "https://deno.land/x/xhr@0.1.0/mod.ts";

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
};

const GROQ_API_KEY = Deno.env.get('GROQ_API_KEY');
const EXA_API_KEY = Deno.env.get('EXA_API_KEY');

interface AgentConfig {
  agent: string;
  systemPrompt: string;
  temperature: number;
  enabled: boolean;
}

async function callGroq(systemPrompt: string, userMessage: string, temperature: number = 0.7, maxTokens: number = 800): Promise<string> {
  const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${GROQ_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      model: 'llama-3.3-70b-versatile',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userMessage }
      ],
      temperature,
      max_tokens: maxTokens,
    }),
  });

  if (!response.ok) {
    const errorText = await response.text();
    console.error('Groq API error:', response.status, errorText);
    
    // Parse rate limit errors
    if (response.status === 429) {
      try {
        const errorData = JSON.parse(errorText);
        const message = errorData.error?.message || 'Rate limit exceeded';
        throw new Error(`RATE_LIMIT: ${message}`);
      } catch {
        throw new Error('RATE_LIMIT: Groq API rate limit exceeded. Please wait before retrying.');
      }
    }
    
    throw new Error(`Groq API failed: ${response.status} - ${errorText}`);
  }

  const data = await response.json();
  if (!data.choices || !data.choices[0] || !data.choices[0].message) {
    console.error('Unexpected Groq response:', data);
    throw new Error('Invalid response from Groq API');
  }
  return data.choices[0].message.content || 'No response';
}

async function researchWithExa(query: string) {
  try {
    const response = await fetch('https://api.exa.ai/search', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${EXA_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        query,
        num_results: 8,
        use_autoprompt: true,
        type: 'neural',
      }),
    });

    const data = await response.json();
    return data.results || [];
  } catch (error) {
    console.error('Exa search error:', error);
    return [];
  }
}

serve(async (req) => {
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  try {
    const { userInput, stage, agentConfigs, roundData, userComment } = await req.json();
    
    // Validate input lengths
    if (userInput && userInput.length > 5000) {
      return new Response(
        JSON.stringify({ error: 'Input too long (max 5000 characters)' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    if (userComment && userComment.length > 1000) {
      return new Response(
        JSON.stringify({ error: 'Comment too long (max 1000 characters)' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    if (!['questions', 'research', 'answers', 'voting', 'spec'].includes(stage)) {
      return new Response(
        JSON.stringify({ error: 'Invalid stage' }),
        { status: 400, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }
    
    console.log('Processing:', { stage, hasConfigs: !!agentConfigs });

    if (stage === 'questions') {
      console.log('Generating clarifying questions...');
      
      const activeAgents = agentConfigs.filter((c: AgentConfig) => c.enabled);
      const questions = [];
      
      for (const config of activeAgents) {
        const questionPrompt = `Input: ${userInput}

Generate 2 critical questions to clarify this spec from your perspective.
Return ONLY a JSON array: [{"question": "...", "context": "...", "importance": "high", "reasoning": "..."}]`;

        const response = await callGroq(config.systemPrompt, questionPrompt, config.temperature, 400);
        try {
          const parsed = JSON.parse(response);
          questions.push(...parsed.map((q: any) => ({ ...q, askedBy: config.agent })));
        } catch {
          questions.push({
            question: response.split('\n')[0],
            context: 'Generated by agent',
            importance: 'high',
            askedBy: config.agent,
            reasoning: response
          });
        }
      }

      return new Response(
        JSON.stringify({ questions }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (stage === 'research') {
      console.log('Researching with Exa...');
      const questions = roundData.questions || [];
      const allResults = [];
      
      for (const q of questions.slice(0, 5)) {
        const results = await researchWithExa(q.question);
        allResults.push(...results);
      }
      
      return new Response(
        JSON.stringify({ research: allResults }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (stage === 'answers') {
      console.log('Generating agent answers...');
      
      const activeAgents = agentConfigs.filter((c: AgentConfig) => c.enabled);
      const questions = roundData.questions || [];
      const research = roundData.research || [];
      
      const answerPromises = activeAgents.map(async (config: AgentConfig) => {
        const context = userComment ? `\nUSER GUIDANCE: ${userComment}\n` : '';
        const researchContext = research.slice(0, 3).map((r: any) => 
          `- ${r.title}: ${r.text || r.snippet}`
        ).join('\n');
        
        const answers = [];
        
        for (const q of questions.slice(0, 3)) {
          if (q.askedBy === config.agent) {
            const prompt = `${context}Q: ${q.question}

Research:
${researchContext}

Answer briefly with your key insight and reasoning.`;
            
            const response = await callGroq(config.systemPrompt, prompt, config.temperature, 500);
            answers.push({
              agent: config.agent,
              question: q.question,
              answer: response,
              reasoning: `Analysis based on ${config.agent} perspective`
            });
          }
        }
        
        return answers;
      });

      const allAnswers = (await Promise.all(answerPromises)).flat();
      
      return new Response(
        JSON.stringify({ answers: allAnswers }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (stage === 'voting') {
      console.log('Collecting votes...');
      
      const activeAgents = agentConfigs.filter((c: AgentConfig) => c.enabled);
      const answers = roundData.answers || [];
      
      const votePromises = activeAgents.map(async (config: AgentConfig) => {
        const answerSummary = answers.map((a: any) => 
          `${a.agent}: ${a.answer.slice(0, 200)}...`
        ).join('\n\n');
        
        const votePrompt = `Answers:
${answerSummary}

Vote YES or NO to proceed. Return JSON: {"approved": true/false, "reasoning": "brief explanation"}`;

        const response = await callGroq(config.systemPrompt, votePrompt, config.temperature, 200);
        
        try {
          const vote = JSON.parse(response);
          return {
            agent: config.agent,
            approved: vote.approved,
            reasoning: vote.reasoning,
            timestamp: new Date().toISOString()
          };
        } catch {
          const approved = response.toLowerCase().includes('yes') || 
                          response.toLowerCase().includes('approve');
          return {
            agent: config.agent,
            approved,
            reasoning: response,
            timestamp: new Date().toISOString()
          };
        }
      });

      const votes = await Promise.all(votePromises);
      
      return new Response(
        JSON.stringify({ votes }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    if (stage === 'spec') {
      console.log('Generating spec...');
      
      const answers = roundData.answers || [];
      const votes = roundData.votes || [];
      
      const context = answers.map((a: any) => 
        `${a.agent}: ${a.answer}`
      ).join('\n\n');
      
      const specPrompt = `Synthesize this analysis into a technical spec:

${context}

Include: 1) Summary 2) Architecture 3) Phases 4) Dependencies 5) Risks 6) Testing
Be concise and actionable. Use markdown.`;

      const spec = await callGroq(
        "You are a senior technical architect. Be concise and specific.",
        specPrompt,
        0.5,
        1200
      );

      const approvedBy = votes.filter((v: any) => v.approved).map((v: any) => v.agent);
      const dissentedBy = votes.filter((v: any) => !v.approved).map((v: any) => v.agent);

      return new Response(
        JSON.stringify({ 
          spec,
          approvedBy,
          dissentedBy
        }),
        { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    throw new Error('Invalid stage');

  } catch (error) {
    console.error('Error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';
    return new Response(
      JSON.stringify({ error: errorMessage }),
      { status: 500, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
    );
  }
});
